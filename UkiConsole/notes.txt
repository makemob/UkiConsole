Change UDP sending to be the right register....
Doiuble check that you are reading and writing the right register!

Add safety checks in the wrapper - distance, accel, etc.

Wow. I know I've been a little slack, but apparently that was two months ago. Time flies in lockdown....

I have ported the wrapper to C#, which seems a little snappier, and given it two threads for the two com ports. The C# wrapper doesn't bother with the full read - it does the same fast read for motor speed, accel, estop status, etc, and then the UI displays that as it changes. I wonder if the "full read" is better handled by reading once on startup, and then letting the board set a flag if something needs attention.

Other than that the wrapper was pretty solid - I ported it to C# and made some minor tweaks, but I haven't changed anything serious. The combination of C# and multi-threading seems to be enough of a win. The modbus library in C# claims to do multi-register read/writes, so that's also another thing I'll look at. 

From here, I still feel pretty nervous about the microswitches :) In theatre, traditionally, they'd be a "hard limit", and hitting them would be a rare and nerve-wracking thing - the "zero" would be a "soft limit" a little before the switch. Using them for calibration makes sense with incremental encoders, especially with the python UI, but I think the next main improvement I'd like to make is giving the UI the ability to move the axes to position, especially small slow moves, so that calibration can be done some other way. If we could move the axis reliably a couple of mm at a time without having to edit the CSV, I think that would enable a change that's really more cultural than technical where we could have "zero" set maybe 10mm away from the switch, and measure and move that if needed. So a visual inspection every now and then that would move the axes all to "zero" (10mm from the switch), and check that they are actually there, and then move them a few mm either way if needed. 

That to me seems to have two advantages. The first is saving wear on the switches every time we calibrate or move to zero. The second is that as far as I can see (and I could be wrong), the position moves to zero don't have much ramp down. The combination of zero being the position after the switches are hit, and the encoders maybe taking a little time to register, and the lack of rampdown all makes me wonder how much that might add up to in terms of overshoot. Having the "zero" 10mm out and an easy way to move the axis would mean never moving so close to the switch, which I think might be handy. We could also then re-enable the inward limit in firmware and set it to -5, which would still be 5mm away from the switch. The UI might then need a way to override that when re-calibration is required - maybe a "safe move" that disables the inner limit but caps the speed/accel when moving near zero.

Which said, the microswitches are definitely triggering and stopping the axes - I was just expecting them to be an estop state, but in hindsight obviously they can't be if they're also the calibration point! 

So, I think I'll start coming back in to the studio a day a week now that lockdown is easing. Initial priorities will be getting the UI to move the axes to a position, having a "safe move" so we can re-enable the firmware inner limit for normal moves, and then we can look at recalibrating "zero" to be further away from the switch, and see if they maintain that over time. It does mean being a bit more diligent about having the axes at zero for power off - I assume that happens generally anyway, so hopefully no big deal. I know I've looked in the past at storing incremental encoder positions in board flash memory for other systems and been scared by how quickly you hit lifetime write limits, but maybe telling the board to save position when the UI/wrapper "quits" is viable.

At the moment, I've kept your approach of a UI and wrapper separate from Unity, which is pretty good practice anyway, but the wrapper still takes UDP commands or could, in theory, be incorporated into someone else's Unity as a library. That seems the flexible approach.

Then I guess I need to dig into the firmware and start by changing the baud rate! The boards are pretty snappy though, and there doesn't seem much to change in the firmware. Maybe adding the "notice me!" flag is another simple change to get my feet wet, and then I can think about some kind of PID style ramp up/down for the position moves. It looks to me like that's mostly done in the CSV scripts with speed settings at the moment, and I guess the Unity interface should be doing its own ramping up and down anyway, so that might be overkill, but it might be nice just to ease off the speed before the position.


-----
Hi Jai - good to hear from you!  

Great to see you’ve managed to convert the wrapper over to C#, have you had a chance to try it on Uki yet?  I’m keen to hear if the two threads wins us a decent speed increase!  And also whether the C# modbus library is a bit more streamlined in terms of delays between messages..  Might need to see the comms on a scope to check that last one out though.

I’m sure the ‘full read’ could be made more efficient, making it event driven might work well, at least if we threshold the rapidly-changing values like current and board temperature.  Although to be honest the full read is only adding a few % to the total loop time at the moment, as it only sends 3 reads out of every 25 (there are 22 boards to poll) and the writes take longer than the read loop anyway so it’s all pretty marginal.  But certainly something to keep in mind once we have the big ticket speed-ups nailed.  

Have you tried the new wrapper alongside Unity yet?  I reckon using multi-write commands from the modbus library would be a good way to accelerate the outgoing messages, but I can’t recall exactly how frequently the Unity side of things is sending out updates so hard to quantify.

Having a manual movement mode in the UI would be SUPER useful for testing things out on site - it’s been on the cards for the Unity side of things for years and would relieve many headaches.  Bonus points if it can show live status data coming back in response to manual movement commands to show when and why things trip..

In terms of the microswitches, there’s certainly no reason why we couldn’t calibrate the actuators a few mm out - in fact this is already implemented for the ‘wing rotate’ actuators in a sense.  They have internal microswitches but the wiring isn’t exposed, so we need to just run them all the way in until they stop (the internal microswitches are wired this way) and then hit the manual calibration button in the UI.  That sends a message to any actuator that requires manual calibration to tell it that it is zeroed.  But I do kinda wonder if that’s a quite a lot of effort to go to, maybe I’m not quite understanding the potential failure mode here?  I mean we could just calibrate to the microswitch once on powerup and then soft-limit movement to a few mm extension during animation so it would never hit the switches anyway, and if it did then it would just stop? The amount of time the actuator takes to ramp down and stop is fairly minimal (despite not tripping the e-stop on the inward microswitch, it does still force a rapid deceleration - line 194 in motor.c).  There’s a bunch of slop in the actuator so it has well and truly stopped before it undershoots inside the enclosure.  

But yeah happy to discuss further if I’m missing something on these inward microswitches, perhaps some easy improvements we could add in.  But worth flagging that the primary issue we have is on over-extension rather than over-retraction and there’s no microswitch at all in that direction!  This is one of the main reasons why we want the Unity model to mirror the physical model, as there are so many axes of movement that there’s no way to include outward microswitches to eliminate limb clashes - each leg can operate within its neighbour's envelope, so Unity needs to identify potential collisions virtually and stop the show if anything is getting too close.  Arguably we would benefit from an extra microswitch on each joint that could trip before the joint overextends and damages itself, but that wouldn’t catch the majority of cases where it hits something else first!

For the firmware, are you set up with LPCXpresso and the programmer etc.?  Definitely keen to hear how things go with the baud rate, it’s a bit of a pain reprogramming all the boards (you need to manually configure the modbus address for each one in turn which is a pretty lousy approach..) and the programming harness is fiddly.  But worth a crack I reckon - need to keep an eye on the comms error rate though, there’s a lot of electrical noise on Uki and it’s caused us drama before!  In terms of larger changes, I really do need to merge in the Helios branch so we have a combined codebase for both projects..  Otherwise if you get too stuck in we’re liable to conflict, I’ve made a lot of changes around how the motion feedback works to accommodate Helios’s analog sensor.  But some kind of control loop to avoid overshoot is needed on those larger actuators so worth thinking about for sure.

Anyhow great work on this one, really pleased to see someone getting stuck into it!  Can’t wait to see Uki running a fully integrated show from Unity..
